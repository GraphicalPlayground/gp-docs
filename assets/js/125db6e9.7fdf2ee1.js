"use strict";(globalThis.webpackChunkgp_docs=globalThis.webpackChunkgp_docs||[]).push([[8471],{9121(e,n,s){s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"engine/cpp-api-reference/runtime/core/math/constants","title":"Constants","description":"Mathematical constants for C++ API.","source":"@site/docs/engine/cpp-api-reference/runtime/core/math/constants.md","sourceDirName":"engine/cpp-api-reference/runtime/core/math","slug":"/engine/cpp-api-reference/runtime/core/math/constants","permalink":"/docs/engine/cpp-api-reference/runtime/core/math/constants","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/engine/cpp-api-reference/runtime/core/math/constants.md","tags":[{"inline":true,"label":"c++","permalink":"/docs/tags/c"},{"inline":true,"label":"math","permalink":"/docs/tags/math"},{"inline":true,"label":"constants","permalink":"/docs/tags/constants"}],"version":"current","frontMatter":{"title":"Constants","description":"Mathematical constants for C++ API.","tags":["c++","math","constants"]},"sidebar":"engineSidebar","previous":{"title":"Color","permalink":"/docs/engine/cpp-api-reference/runtime/core/math/color"},"next":{"title":"Dual Quaternion","permalink":"/docs/engine/cpp-api-reference/runtime/core/math/dual-quaternion"}}');var i=s(4848),t=s(8453);const c={title:"Constants",description:"Mathematical constants for C++ API.",tags:["c++","math","constants"]},a="Constants",o={},l=[{value:"Definition",id:"definition",level:2},{value:"Public Members",id:"public-members",level:2},{value:"Pi",id:"pi",level:3},{value:"Conversion",id:"conversion",level:3},{value:"Mathematical Constants",id:"mathematical-constants",level:3},{value:"Limits",id:"limits",level:3},{value:"Tolerance",id:"tolerance",level:3},{value:"Thresholds",id:"thresholds",level:3},{value:"Example Usage",id:"example-usage",level:2},{value:"Source",id:"source",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"constants",children:"Constants"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Constants"})," struct provides a collection of mathematical constants and conversion factors for floating-point types. It includes values such as Pi, Euler's number, and various limits and thresholds that are commonly used in mathematical computations."]}),"\n",(0,i.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",metastring:"showLineNumbers",children:"template <Concepts::IsFloatingPoint T>\nstruct Constants final\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," The ",(0,i.jsx)(n.code,{children:"Constants"})," struct is designed for floating-point types and should not be used with integer types. Attempting to use it with non-floating-point types will result in a compilation error due to the ",(0,i.jsx)(n.code,{children:"IsFloatingPoint"})," concept constraint."]})}),"\n",(0,i.jsx)(n.h2,{id:"public-members",children:"Public Members"}),"\n",(0,i.jsx)(n.h3,{id:"pi",children:"Pi"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T Pi;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The mathematical constant \u03c0 \u2248 ",(0,i.jsx)(n.code,{children:"3.14159265358979323846"}),". Sourced from ",(0,i.jsx)(n.code,{children:"std::numbers::pi_v<T>"}),"."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T TwoPi;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Two times \u03c0 \u2248 ",(0,i.jsx)(n.code,{children:"6.28318530717958647692"}),". Represents a full rotation in radians and is commonly used in periodic functions and angular wrapping."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T HalfPi;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Half of \u03c0 \u2248 ",(0,i.jsx)(n.code,{children:"1.57079632679489661923"}),". Represents a 90-degree rotation in radians. Frequently used in trigonometric identities and orientation math."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T QuarterPi;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["One quarter of \u03c0 \u2248 ",(0,i.jsx)(n.code,{children:"0.78539816339744830961"}),". Represents a 45-degree rotation in radians."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T InvPi;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The multiplicative inverse of \u03c0 \u2248 ",(0,i.jsx)(n.code,{children:"0.31830988618379067153"}),". Sourced from ",(0,i.jsx)(n.code,{children:"std::numbers::inv_pi_v<T>"}),". Useful for normalizing values that are expressed as multiples of \u03c0."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T InvTwoPi;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The multiplicative inverse of 2\u03c0 \u2248 ",(0,i.jsx)(n.code,{children:"0.15915494309189533576"}),". Useful for converting radians into a normalized ",(0,i.jsx)(n.code,{children:"[0, 1]"})," frequency range."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"conversion",children:"Conversion"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T DegToRad;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Conversion factor from degrees to radians \u2014 equivalent to ",(0,i.jsx)(n.code,{children:"\u03c0 / 180"}),". Multiply a degree value by this constant to obtain its radian equivalent."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T RadToDeg;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Conversion factor from radians to degrees \u2014 equivalent to ",(0,i.jsx)(n.code,{children:"180 / \u03c0"}),". Multiply a radian value by this constant to obtain its degree equivalent."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"mathematical-constants",children:"Mathematical Constants"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T E;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Euler's number \u2248 ",(0,i.jsx)(n.code,{children:"2.71828182845904523536"}),". The base of the natural logarithm. Sourced from ",(0,i.jsx)(n.code,{children:"std::numbers::e_v<T>"}),"."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T Sqrt2;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The square root of 2 \u2248 ",(0,i.jsx)(n.code,{children:"1.41421356237309504880"}),". Sourced from ",(0,i.jsx)(n.code,{children:"std::numbers::sqrt2_v<T>"}),". Commonly appears in diagonal distance calculations and rotation matrices."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T Sqrt3;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The square root of 3 \u2248 ",(0,i.jsx)(n.code,{children:"1.73205080756887729352"}),". Frequently used in hexagonal grid math and equilateral triangle geometry."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T InvSqrt2;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The multiplicative inverse of \u221a2 \u2248 ",(0,i.jsx)(n.code,{children:"0.70710678118654752440"}),". Equivalent to ",(0,i.jsx)(n.code,{children:"1 / \u221a2"})," or ",(0,i.jsx)(n.code,{children:"\u221a2 / 2"}),". Commonly used to construct 45-degree unit vectors."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T Ln2;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The natural logarithm of 2 \u2248 ",(0,i.jsx)(n.code,{children:"0.69314718055994530941"}),". Sourced from ",(0,i.jsx)(n.code,{children:"std::numbers::ln2_v<T>"}),". Used in exponential decay and octave-based frequency calculations."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T Ln10;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The natural logarithm of 10 \u2248 ",(0,i.jsx)(n.code,{children:"2.30258509299404568401"}),". Sourced from ",(0,i.jsx)(n.code,{children:"std::numbers::ln10_v<T>"}),". Used for converting between natural and base-10 logarithms."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T Log2E;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The base-2 logarithm of Euler's number \u2248 ",(0,i.jsx)(n.code,{children:"1.44269504088896340735"}),". Sourced from ",(0,i.jsx)(n.code,{children:"std::numbers::log2e_v<T>"}),". Useful for fast power-of-two exponent computations."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T Log10E;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The base-10 logarithm of Euler's number \u2248 ",(0,i.jsx)(n.code,{children:"0.43429448190325182765"}),". Sourced from ",(0,i.jsx)(n.code,{children:"std::numbers::log10e_v<T>"}),"."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T Phi;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The golden ratio \u03c6 \u2248 ",(0,i.jsx)(n.code,{children:"1.61803398874989484820"}),". Sourced from ",(0,i.jsx)(n.code,{children:"std::numbers::phi_v<T>"}),". Appears in procedural geometry, aesthetics-driven layout systems, and Fibonacci-based sequences."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"limits",children:"Limits"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T Epsilon;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The smallest representable difference between two distinct floating-point values of type ",(0,i.jsx)(n.code,{children:"T"}),". Sourced from ",(0,i.jsx)(n.code,{children:"std::numeric_limits<T>::epsilon()"}),". Used as a baseline for floating-point equality comparisons."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T Infinity;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Positive infinity for type ",(0,i.jsx)(n.code,{children:"T"}),". Sourced from ",(0,i.jsx)(n.code,{children:"std::numeric_limits<T>::infinity()"}),". Useful as a sentinel value in distance queries, BVH traversal, and min/max initialization."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"tolerance",children:"Tolerance"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T SmallNumber;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["A very small number (",(0,i.jsx)(n.code,{children:"1e-8"}),"). Suitable for high-precision near-zero comparisons where ",(0,i.jsx)(n.code,{children:"Epsilon"})," may be too strict."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T KindaSmallNumber;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["A moderately small number (",(0,i.jsx)(n.code,{children:"1e-4"}),"). Used when a looser near-zero threshold is acceptable, such as in physics simulations or animation blending."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T BigNumber;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["A large finite number (",(0,i.jsx)(n.code,{children:"3.4e+38"}),"). Useful as a practical stand-in for infinity in systems where IEEE infinity is undesirable, such as certain physics solvers or serialized data ranges."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T Delta;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["A general-purpose small delta value (",(0,i.jsx)(n.code,{children:"0.00001"}),"). Commonly used as a nudge factor or a safe margin in geometric intersection tests."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"thresholds",children:"Thresholds"}),"\n",(0,i.jsxs)(n.p,{children:["Thresholds are used to determine when two floating-point numbers are considered equal or when a number is close enough to zero. All threshold values are defined within the nested ",(0,i.jsx)(n.code,{children:"Thresholds"})," struct."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",metastring:"showLineNumbers",children:"struct Thresholds final\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T Normal;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Minimum acceptable length for a vector to be considered normalized (",(0,i.jsx)(n.code,{children:"0.0001"}),"). Set to half the maximum meaningful value to prevent dot product overflow when operating on normalized vectors."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T PointOnPlane;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Half-thickness of a plane used in front/back/inside classification tests (",(0,i.jsx)(n.code,{children:"0.10"}),"). Points within this distance of a plane are considered coplanar."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T PointOnSide;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Half-thickness of a polygon edge's side-plane used in point-inside/outside/on-side tests (",(0,i.jsx)(n.code,{children:"0.20"}),")."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T PointsAreSame;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Maximum distance between two points for them to be considered identical (",(0,i.jsx)(n.code,{children:"0.00002"}),"). Used in mesh welding, deduplication, and CSG operations."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T PointsAreNear;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Maximum distance between two points for them to be considered near-enough to merge when imprecise math is acceptable (",(0,i.jsx)(n.code,{children:"0.015"}),")."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T NormalsAreSame;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Maximum angular deviation between two normals for them to be considered identical (",(0,i.jsx)(n.code,{children:"0.00002"}),"). Used in normal averaging and smoothing group classification."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T UVsAreSame;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Maximum difference between two UV coordinates for them to be considered the same (",(0,i.jsx)(n.code,{children:"0.0009765625"}),", equivalent to ",(0,i.jsx)(n.code,{children:"1 / 1024"}),")."]}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsx)(n.p,{children:"Setting this value too large will cause incorrect CSG classification and UV seam artifacts."})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T VectorsAreNear;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Maximum distance between two vectors for them to be considered near-enough to merge when imprecise math is acceptable (",(0,i.jsx)(n.code,{children:"0.0004"}),")."]}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsx)(n.p,{children:"Setting this value too large can introduce lighting artifacts caused by inaccurate texture coordinate interpolation."})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T SplitPolygonWithPlane;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Distance threshold at which a plane is considered to split a polygon in half (",(0,i.jsx)(n.code,{children:"0.25"}),"). Used in BSP tree construction and convex decomposition."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T SplitPolygonPrecisely;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["A tighter distance threshold for precise polygon splitting (",(0,i.jsx)(n.code,{children:"0.01"}),"). Used when high-fidelity BSP splits are required."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T ZeroNormSquared;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The squared magnitude threshold below which a unit normal is considered degenerate (zero-length) (",(0,i.jsx)(n.code,{children:"0.0001"}),")."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T NormalsAreParallel;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Minimum absolute dot product between two unit vectors for them to be considered parallel (",(0,i.jsx)(n.code,{children:"0.999845"}),"). Approximately equivalent to ",(0,i.jsx)(n.code,{children:"cos(1.0\xb0)"}),"."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T NormalsAreOrthogonal;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Maximum absolute dot product between two unit vectors for them to be considered orthogonal (perpendicular) (",(0,i.jsx)(n.code,{children:"0.017455"}),"). Approximately equivalent to ",(0,i.jsx)(n.code,{children:"cos(89.0\xb0)"}),"."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T VectorNormalized;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Maximum allowed deviation of a vector's squared magnitude from ",(0,i.jsx)(n.code,{children:"1.0"})," for it to be considered normalized (",(0,i.jsx)(n.code,{children:"0.01"}),")."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr T QuaternionNormalized;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Maximum allowed deviation of a quaternion's squared magnitude from ",(0,i.jsx)(n.code,{children:"1.0"})," for it to be considered normalized (",(0,i.jsx)(n.code,{children:"0.01"}),")."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"example-usage",children:"Example Usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",metastring:"showLineNumbers",children:'#include "Math/Constants.hpp"\n\nusing FloatConstants = GP::Math::Constants<float>;\nusing DoubleConstants = GP::Math::Constants<double>;\n\n// Convert 90 degrees to radians\nfloat radians = 90.0f * FloatConstants::DegToRad;\n\n// Check if a vector length is degenerate\nbool isDegenerate = squaredLength < FloatConstants::Thresholds::ZeroNormSquared;\n\n// Use infinity as a sentinel for BVH traversal\nfloat tMin = FloatConstants::Infinity;\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"source",children:"Source"}),"\n",(0,i.jsxs)(n.p,{children:["The full source for ",(0,i.jsx)(n.code,{children:"Constants"})," is available in the engine repository:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/GraphicalPlayground/gp-engine/blob/main/Source/Runtime/Core/Public/Math/Utils/Constants.hpp",children:(0,i.jsx)(n.code,{children:"Source/Runtime/Core/Public/Math/Utils/Constants.hpp"})})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,n,s){s.d(n,{R:()=>c,x:()=>a});var r=s(6540);const i={},t=r.createContext(i);function c(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);